package com.robotforest.launcher;

import android.content.Context;
import android.content.res.AssetManager;
import android.util.Log;

import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;

public class RuntimeUnpacker {
    private static final String TAG = "RF/RuntimeUnpacker";

    /** Copy everything under assets/runtime/** into filesDir/runtime/** (idempotent). */
    public static File unpackRuntime(Context ctx) throws Exception {
        File outRoot = new File(ctx.getFilesDir(), "runtime");
        if (!outRoot.exists() && !outRoot.mkdirs()) {
            throw new RuntimeException("Failed to create runtime dir: " + outRoot);
        }

        AssetManager am = ctx.getAssets();
        // Top-level known subdirs/files we created earlier:
        // runtime/{README.txt, bin/hello.bin, etc/, share/}
        copyAsset(am, "runtime/README.txt", new File(outRoot, "README.txt"));
        copyAssetDir(am, "runtime/bin", new File(outRoot, "bin"));
        copyAssetDir(am, "runtime/etc", new File(outRoot, "etc"));
        copyAssetDir(am, "runtime/share", new File(outRoot, "share"));

        // Best-effort: mark bin/* executable
        File bin = new File(outRoot, "bin");
        if (bin.isDirectory()) {
            File[] kids = bin.listFiles();
            if (kids != null) {
                for (File f : kids) {
                    // Not strictly required for shell-scripts run via `sh -c`, but helps later.
                    //noinspection ResultOfMethodCallIgnored
                    f.setExecutable(true, false);
                }
            }
        }
        Log.i(TAG, "Runtime unpacked to: " + outRoot.getAbsolutePath());
        return outRoot;
    }

    private static void copyAssetDir(AssetManager am, String assetDirPath, File outDir) throws Exception {
        if (!outDir.exists() && !outDir.mkdirs()) {
            throw new RuntimeException("Failed to mkdir: " + outDir);
        }
        String[] list = am.list(assetDirPath);
        if (list == null) return;
        for (String name : list) {
            String childAsset = assetDirPath + "/" + name;
            String[] maybeNested = am.list(childAsset);
            if (maybeNested != null && maybeNested.length > 0) {
                copyAssetDir(am, childAsset, new File(outDir, name));
            } else {
                copyAsset(am, childAsset, new File(outDir, name));
            }
        }
    }

    private static void copyAsset(AssetManager am, String assetPath, File outFile) throws Exception {
        // Idempotent: only overwrite if different size or not exists (simple heuristic).
        long assetLen = -1L;
        try (InputStream is = am.open(assetPath)) {
            assetLen = is.available();
        } catch (Throwable t) {
            // ignore; may be a directory
        }

        if (outFile.exists() && assetLen > 0 && outFile.length() == assetLen) {
            return; // looks identical; skip
        }

        try (InputStream in = am.open(assetPath);
             FileOutputStream out = new FileOutputStream(outFile)) {
            byte[] buf = new byte[64 * 1024];
            int r;
            while ((r = in.read(buf)) != -1) {
                out.write(buf, 0, r);
            }
        }
    }
}
